---
title: "Final Report Code"
author: "Daniel Finley"
date: "11/15/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Set up the libraries
```{r}
library(tidyverse)
library(rpart)
library(rpart.plot)
library(knitr)
library(ggplot2)
library(plyr)
library(dplyr)
library(caret)
library(gridExtra)
library(scales)
library(Rmisc)
library(ggrepel)
library(randomForest)
library(psych)
library(xgboost)
library(corrplot)

```


## Load the data
```{r}
test <- read_csv("test.csv")
train <- read_csv("train.csv")
```


## Cleaning
```{r}
#Street
train$Street[train$Street == "Pave"] <- 1
train$Street[train$Street != "Pave"] <- 0

#LotShape
train$LotShape[train$LotShape == "Reg"] <- 1
train$LotShape[train$LotShape != "Reg"] <- 0

#Remove large NA Variables
train <- train %>% select(-c("PoolQC", "MiscFeature", "Alley", "Fence", "Utilities"))
test <- test %>% select(-c("PoolQC", "MiscFeature", "Alley", "Fence", "Utilities"))

summary(train)
```

## View NA's
```{r}
#view na's
colSums(sapply(train,is.na))
```




## Overview of the data
In this dataset multicollinearity is a major issue: 
GarageCars + GarageArea
Bsmt Variables
...


### 1. OverallQual - One of the highest drivers. 
```{r}
ggplot(data=train[!is.na(train$SalePrice),], aes(x=factor(OverallQual), y=SalePrice))+
        geom_boxplot(col='blue') + labs(x='Overall Quality') +
        scale_y_continuous(breaks= seq(0, 800000, by=100000), labels = comma)
```
You can see a strong upward trend in Sale Price as the Overall Quality goes up. We expect this kind of behavior so it doesn't come as a surprise but we can use this as one of our main predictors. The outliers we see are in the expected range as well. 



### 2. Above ground living area
```{r}
ggplot(data=train[!is.na(train$SalePrice),], aes(x=GrLivArea, y=SalePrice))+
        geom_point(col='blue') + geom_smooth(method = "lm", se=FALSE, color="black", aes(group=1)) +
        scale_y_continuous(breaks= seq(0, 800000, by=100000), labels = comma)

#Taking a peek at the outliers: 

train[c(524, 1299), c('SalePrice', 'GrLivArea', 'OverallQual', "Neighborhood")]

train %>% filter(Id == 1299) %>% head
```
- Another strong driver of sale price...though there are a few outliers pulling the average. hmmmm....high area and high qual but low saleprice. Doesnt look to be related to SaleCondition either. 




## Looking at missing data: 
```{r}
NAcol <- which(colSums(is.na(train)) > 0)
sort(colSums(sapply(train[NAcol], is.na)), decreasing = TRUE)
```
Drop Features - PoolQC, MiscFeature, Fence, Alley(possibly bring Alley back as there may be a slight increase from Grvl to Pave), Utilities(most houses have all public utilities)



# Testing Neighborhood
```{r}
ggplot(data=train[!is.na(train$SalePrice),], aes(x=Neighborhood, y=SalePrice))+
        geom_point(col='blue') + geom_smooth(method = "lm", se=FALSE, color="black", aes(group=1)) +
        scale_y_continuous(breaks= seq(0, 800000, by=100000), labels = comma)+   
        scale_x_discrete(guide = guide_axis(n.dodge=3))

#------------------------------------Need a better chart to visualize Neighborhood----------------------------

n1 <- ggplot(train[!is.na(train$SalePrice),], aes(x=Neighborhood, y=SalePrice)) +
        geom_bar(stat='summary', fun.y = "median", fill='blue') +
        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
        scale_y_continuous(breaks= seq(0, 800000, by=50000), labels = comma) +
        geom_label(stat = "count", aes(label = ..count.., y = ..count..), size=3) +
        geom_hline(yintercept=163000, linetype="dashed", color = "red")
```
No clear data here




















## Fixing the missing data: 
```{r}
NAcol <- which(colSums(is.na(train)) > 0)
sort(colSums(sapply(train[NAcol], is.na)), decreasing = TRUE)
```
##-----------------------------------------------------------------------Fireplace-------------------------------------------------------------
###Fireplace variables

**Fireplace quality, and Number of fireplaces**

Within Fireplace Quality, there are 690 NAs. Number of fireplaces is complete.

**Fireplace quality**

The number of NAs in FireplaceQu matches the number of houses with 0 fireplaces. This means that I can safely replace the NAs in FireplaceQu with 'no fireplace'. The values are ordinal, and I can use the Qualities vector that I have already created for the Pool Quality. Values:

       Ex	Excellent - Exceptional Masonry Fireplace
       Gd	Good - Masonry Fireplace in main level
       TA	Average - Prefabricated Fireplace in main living area or Masonry Fireplace in basement
       Fa	Fair - Prefabricated Fireplace in basement
       Po	Poor - Ben Franklin Stove
       NA	No Fireplace

```{r}
train$FireplaceQu[is.na(train$FireplaceQu)] <- 'None'

Qualities <- c('None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)

train$FireplaceQu<-as.integer(revalue(train$FireplaceQu, Qualities))
table(train$FireplaceQu)
```

**Number of fireplaces**

Fireplaces is an integer variable, and there are no missing values.
```{r}
table(train$Fireplaces)
sum(table(train$Fireplaces))
```


##-----------------------------------------------------------------------Lot-------------------------------------------------------------
###Lot variables

3 variables. One with 1 NA, and 2 complete variables.

**LotFrontage: Linear feet of street connected to property**

256 NAs. The most reasonable imputation seems to take the median per neighborhood.

```{r}
ggplot(train[!is.na(train$LotFrontage),], aes(x=as.factor(Neighborhood), y=LotFrontage)) +
        geom_bar(stat='summary', fun.y = "median", fill='blue') +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
for (i in 1:nrow(train)){
        if(is.na(train$LotFrontage[i])){
               train$LotFrontage[i] <- as.integer(median(train$LotFrontage[train$Neighborhood==train$Neighborhood[i]], na.rm=TRUE)) 
        }
}
```

**LotShape: General shape of property**

No NAs. Values seem ordinal (Regular=best)

       Reg	Regular	
       IR1	Slightly irregular
       IR2	Moderately Irregular
       IR3	Irregular

```{r}
train$LotShape<-as.integer(revalue(train$LotShape, c('IR3'=0, 'IR2'=1, 'IR1'=2, 'Reg'=3)))
table(train$LotShape)
sum(table(train$LotShape))
```

**LotConfig: Lot configuration**

No NAs. The values seemed possibly ordinal to me, but the visualization does not show this. Therefore, I will convert the variable into a factor.

       Inside	Inside lot
       Corner	Corner lot
       CulDSac	Cul-de-sac
       FR2	Frontage on 2 sides of property
       FR3	Frontage on 3 sides of property
       
```{r}
ggplot(train[!is.na(train$SalePrice),], aes(x=as.factor(LotConfig), y=SalePrice)) +
        geom_bar(stat='summary', fun.y = "median", fill='blue')+
        scale_y_continuous(breaks= seq(0, 800000, by=100000), labels = comma) +
        geom_label(stat = "count", aes(label = ..count.., y = ..count..))
```

```{r}
train$LotConfig <- as.factor(train$LotConfig)
table(train$LotConfig)
sum(table(train$LotConfig))
```

##--------------------------------------------Daniel's Notes: not sure what came out of the lot section. 

##-----------------------------------------------------------------------Garage-------------------------------------------------------------
###Garage variables

**Altogether, there are 5 variables related to garages**

variables have 81 NAs. 

First of all, I am going to replace all 81 missing **GarageYrBlt: Year garage was built** values with the values in YearBuilt (this is similar to YearRemodAdd, which also defaults to YearBuilt if no remodeling or additions).

```{r}
train$GarageYrBlt[is.na(train$GarageYrBlt)] <- train$YearBuilt[is.na(train$GarageYrBlt)]
```

**GarageType: Garage location**

The values do not seem ordinal, so I will convert into a factor.

       2Types	More than one type of garage
       Attchd	Attached to home
       Basment	Basement Garage
       BuiltIn	Built-In (Garage part of house - typically has room above garage)
       CarPort	Car Port
       Detchd	Detached from home
       NA	No Garage

```{r}
train$GarageType[is.na(train$GarageType)] <- 'No Garage'
train$GarageType <- as.factor(train$GarageType)
table(train$GarageType)
```

**GarageFinish: Interior finish of the garage**

The values are ordinal.

       Fin	Finished
       RFn	Rough Finished	
       Unf	Unfinished
       NA	No Garage       

```{r}
train$GarageFinish[is.na(train$GarageFinish)] <- 'None'
Finish <- c('None'=0, 'Unf'=1, 'RFn'=2, 'Fin'=3)

train$GarageFinish<-as.integer(revalue(train$GarageFinish, Finish))
table(train$GarageFinish)
```

**GarageQual: Garage quality**

Another variable than can be made ordinal with the Qualities vector.

       Ex	Excellent
       Gd	Good
       TA	Typical/Average
       Fa	Fair
       Po	Poor
       NA	No Garage
       
```{r}
train$GarageQual[is.na(train$GarageQual)] <- 'None'
train$GarageQual<-as.integer(revalue(train$GarageQual, Qualities))
table(train$GarageQual)
```

**GarageCond: Garage condition**

Another variable than can be made ordinal with the Qualities vector.

       Ex	Excellent
       Gd	Good
       TA	Typical/Average
       Fa	Fair
       Po	Poor
       NA	No Garage

```{r}
train$GarageCond[is.na(train$GarageCond)] <- 'None'
train$GarageCond<-as.integer(revalue(train$GarageCond, Qualities))
table(train$GarageCond)
```

##-----------------------------------------------------------------------Basement-------------------------------------------------------------

###Basement Variables

**Altogether, there are 5 variables that relate to the Basement of a house**

So altogether, it seems as if there are 79 houses without a basement, because the basement variables of the other houses with missing values are all 80% complete (missing 1 out of 5 values). I am going to impute the modes to fix those 9 houses.


**BsmtQual: Evaluates the height of the basement**

A variable than can be made ordinal with the Qualities vector.

       Ex	Excellent (100+ inches)	
       Gd	Good (90-99 inches)
       TA	Typical (80-89 inches)
       Fa	Fair (70-79 inches)
       Po	Poor (<70 inches
       NA	No Basement

```{r, message=FALSE}
train$BsmtQual[is.na(train$BsmtQual)] <- 'None'
train$BsmtQual<-as.integer(revalue(train$BsmtQual, Qualities))
table(train$BsmtQual)
```
		
**BsmtCond: Evaluates the general condition of the basement**

A variable than can be made ordinal with the Qualities vector.

       Ex	Excellent
       Gd	Good
       TA	Typical - slight dampness allowed
       Fa	Fair - dampness or some cracking or settling
       Po	Poor - Severe cracking, settling, or wetness
       NA	No Basement

```{r, message=FALSE}
train$BsmtCond[is.na(train$BsmtCond)] <- 'None'
train$BsmtCond<-as.integer(revalue(train$BsmtCond, Qualities))
table(train$BsmtCond)
```
	
**BsmtExposure: Refers to walkout or garden level walls**

A variable than can be made ordinal.

       Gd	Good Exposure
       Av	Average Exposure (split levels or foyers typically score average or above)	
       Mn	Mimimum Exposure
       No	No Exposure
       NA	No Basement

```{r}
train$BsmtExposure[is.na(train$BsmtExposure)] <- 'None'
Exposure <- c('None'=0, 'No'=1, 'Mn'=2, 'Av'=3, 'Gd'=4)

train$BsmtExposure<-as.integer(revalue(train$BsmtExposure, Exposure))
table(train$BsmtExposure)
```
       
**BsmtFinType1: Rating of basement finished area**

A variable than can be made ordinal.

       GLQ	Good Living Quarters
       ALQ	Average Living Quarters
       BLQ	Below Average Living Quarters	
       Rec	Average Rec Room
       LwQ	Low Quality
       Unf	Unfinshed
       NA	No Basement
		
```{r}
train$BsmtFinType1[is.na(train$BsmtFinType1)] <- 'None'
FinType <- c('None'=0, 'Unf'=1, 'LwQ'=2, 'Rec'=3, 'BLQ'=4, 'ALQ'=5, 'GLQ'=6)

train$BsmtFinType1<-as.integer(revalue(train$BsmtFinType1, FinType))
table(train$BsmtFinType1)
```

**BsmtFinType2: Rating of basement finished area (if multiple types)**

A variable than can be made ordinal with the FinType vector.

       GLQ	Good Living Quarters
       ALQ	Average Living Quarters
       BLQ	Below Average Living Quarters	
       Rec	Average Rec Room
       LwQ	Low Quality
       Unf	Unfinshed
       NA	No Basement

```{r}
train$BsmtFinType2[is.na(train$BsmtFinType2)] <- 'None'
FinType <- c('None'=0, 'Unf'=1, 'LwQ'=2, 'Rec'=3, 'BLQ'=4, 'ALQ'=5, 'GLQ'=6)

train$BsmtFinType2<-as.integer(revalue(train$BsmtFinType2, FinType))
table(train$BsmtFinType2)
```

##-----------------------------------------------------------------------Masonry-------------------------------------------------------------

###Masonry variables

**Masonry veneer type, and masonry veneer area**

Masonry veneer type has 8 NAs. Masonry veneer area has 8 NAs. If a house has a veneer area, it should also have a masonry veneer type. 


**Masonry veneer type**

Will check the ordinality below.

       BrkCmn	Brick Common
       BrkFace	Brick Face
       CBlock	Cinder Block
       None	None
       Stone	Stone

```{r}
train$MasVnrType[is.na(train$MasVnrType)] <- 'None'
```

There seems to be a significant difference between "common brick/none" and the other types. I assume that simple stones and for instance wooden houses are just cheaper. I will make the ordinality accordingly.

```{r}
Masonry <- c('None'=0, 'BrkCmn'=0, 'BrkFace'=1, 'Stone'=2)
train$MasVnrType<-as.integer(revalue(train$MasVnrType, Masonry))
table(train$MasVnrType)
```

**MasVnrArea: Masonry veneer area in square feet**

An integer variable.
```{r}
train$MasVnrArea[is.na(train$MasVnrArea)] <-0
```

##-----------------------------------------------------------------------Electrical-------------------------------------------------------------

###Electrical system

**Electrical: Electrical system**

1 NA. Values are categorical.

       SBrkr	Standard Circuit Breakers & Romex
       FuseA	Fuse Box over 60 AMP and all Romex wiring (Average)	
       FuseF	60 AMP Fuse Box and mostly Romex wiring (Fair)
       FuseP	60 AMP Fuse Box and mostly knob & tube wiring (poor)
       Mix	Mixed

```{r}
#imputing mode
train$Electrical[is.na(train$Electrical)] <- names(sort(-table(train$Electrical)))[1]

train$Electrical <- as.factor(train$Electrical)
table(train$Electrical)
sum(table(train$Electrical))
```






























1. Take a look at the OverallQual Variable
```{r}
table(train$OverallQual)

```
10 factors here which appear to form a bell shaped curve around 5.5. Should be able to leave this variable alone but will need to expand on it in the final project and include some co-linearity. 


2. Neighborhood
```{r}
table(train$Neighborhood)
```
```{r}
factor(train$Neighborhood) %>% levels
```
```{r}
factor(test$Neighborhood) %>% levels
```

3. GrLivArea
```{r}
table(train$GrLivArea)
```

4. 1stFlrSF
```{r}
table(train$"1stFlrSF")
```

5. TotalBsmtSF
```{r}
table(train$TotalBsmtSF)
```


Model Prep
```{r}
outcome <- train$SalePrice

partition <- createDataPartition(y = outcome, 
                                 p = .5, 
                                 list = F)


training <- train[partition,]
testing <- train[-partition,]
```


Run a linear model - Since our outcome is a continuous numeric variable, we want a linear model, not a GLM. 
```{r}
#with Partition
lm_model_5 <- lm(log(SalePrice) ~ OverallQual+Neighborhood+GrLivArea+`1stFlrSF`+TotalBsmtSF, data = training)

#Without Partition
#lm_model_55 <- lm(SalePrice ~ OverallQual+Neighborhood+GrLivArea+`1stFlrSF`+TotalBsmtSF, data = train)

summary(lm_model_5)

#lm_model_6 <- lm(log(SalePrice) ~ OverallQual+Neighborhood+GrLivArea+`1stFlrSF`+TotalBsmtSF, data = testing) 

#summary(lm_model_6)




```


RMSE
```{r}
#prediction <- predict(lm_model_5, testing, type="response")
#model_output <- cbind(testing, prediction)

#model_output$log_prediction <- log(model_output$prediction)
#model_output$log_SalePrice <- log(model_output$SalePrice)

#Test with RMSE

#postResample(model_output$log_SalePrice,model_output$log_prediction)




summary(lm_model_5)$r.square
summary(lm_model_5)$r.square

#RMSE
rmse <- function(actual, fitted){
  sqrt(mean((actual - fitted)^2))
}

rmse(training$SalePrice, fitted(lm_model_5))
rmse(testing$SalePrice, fitted(lm_model_5))

# need to exponentiate the log value
rmse(training$SalePrice, exp(fitted(lm_model_5)))
rmse(testing$SalePrice, exp(fitted(lm_model_5)))
```





Prepare the prediction data
```{r}
predicted_prices <- exp(predict(lm_model_5, newdata = test))

#Quick Look
head(predicted_prices)
```

Prepare Submission File
```{r}
# create a dataframe with our results
our_submission <- tibble('Id' = as.integer(test$Id), 'SalePrice' = predicted_prices)

# save our file
write_csv(our_submission, 'submission5.csv')

head(our_submission)
summary(our_submission)


```

```{r}
test1 <- test
train1 <- train

train1$TotalBsmtSF[is.na(train1$TotalBsmtSF)] <- 0 

summary(train1)

test1$TotalBsmtSF[is.na(test1$TotalBsmtSF)] <- 0 

summary(test1)

```










